<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TDG Debug - Tower Placement Test</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background: #f0f0f0; }
        canvas { border: 2px solid #333; background: #2d2d2d; display: block; margin: 20px auto; }
        .controls { text-align: center; margin: 20px; }
        button { margin: 5px; padding: 10px 20px; font-size: 14px; cursor: pointer; }
        .status { padding: 15px; margin: 20px auto; max-width: 800px; background: white; border-radius: 5px; }
        .error { background: #f8d7da; border: 1px solid #f5c6cb; color: #721c24; }
        .success { background: #d4edda; border: 1px solid #c3e6cb; color: #155724; }
        .info { background: #d1ecf1; border: 1px solid #b6d4df; color: #0c5460; }
    </style>
</head>
<body>
    <h1>TDG Debug: Tower Placement & Animation Test</h1>
    
    <canvas id="debugCanvas" width="800" height="600"></canvas>
    
    <div class="controls">
        <button onclick="placeTower('basic')">Place Basic Tower</button>
        <button onclick="placeTower('sniper')">Place Sniper Tower</button>
        <button onclick="placeTower('rapid')">Place Rapid Tower</button>
        <button onclick="spawnEnemy()">Spawn Enemy</button>
        <button onclick="clearAll()">Clear All</button>
    </div>

    <div id="status" class="status info">
        <strong>Status:</strong> Loading...
    </div>

    <script type="module">
        import Tower from './src/entities/tower.js';
        import Enemy from './src/entities/enemy.js';
        
        // Test state
        let canvas, ctx;
        let towers = [];
        let enemies = [];
        let lastTime = 0;
        let testPath = [
            { x: 50, y: 300 },
            { x: 200, y: 300 },
            { x: 200, y: 150 },
            { x: 400, y: 150 },
            { x: 400, y: 450 },
            { x: 600, y: 450 },
            { x: 750, y: 300 }
        ];

        function log(message, type = 'info') {
            const statusEl = document.getElementById('status');
            const div = document.createElement('div');
            div.className = `status ${type}`;
            div.innerHTML = `<strong>${type.toUpperCase()}:</strong> ${message}`;
            statusEl.appendChild(div);
            console.log(`[${type.toUpperCase()}] ${message}`);
        }

        async function initDebugTest() {
            try {
                canvas = document.getElementById('debugCanvas');
                ctx = canvas.getContext('2d');
                
                log('Debug test initialized', 'success');
                log('Canvas: ' + canvas.width + 'x' + canvas.height, 'info');
                
                // Start render loop
                requestAnimationFrame(gameLoop);
                
            } catch (error) {
                log('Failed to initialize: ' + error.message, 'error');
                console.error('Init error:', error);
            }
        }

        function gameLoop(currentTime) {
            const deltaTime = (currentTime - lastTime) / 1000;
            lastTime = currentTime;

            // Clear canvas
            ctx.fillStyle = '#2d2d2d';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw path
            drawPath();
            
            try {
                // Update and render towers
                const currentTimeMs = performance.now();
                for (const tower of towers) {
                    tower.update(deltaTime, currentTimeMs, enemies);
                    tower.render(ctx, 1);
                }

                // Update and render enemies
                for (const enemy of enemies) {
                    enemy.update(deltaTime);
                    enemy.render(ctx, 1);
                }
                
                // Clean up dead enemies
                enemies = enemies.filter(enemy => !enemy.isDead);
                
            } catch (error) {
                log('Render error: ' + error.message, 'error');
                console.error('Render error:', error);
            }

            requestAnimationFrame(gameLoop);
        }

        function drawPath() {
            ctx.strokeStyle = '#8b7355';
            ctx.lineWidth = 40;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.beginPath();
            
            testPath.forEach((point, index) => {
                if (index === 0) {
                    ctx.moveTo(point.x, point.y);
                } else {
                    ctx.lineTo(point.x, point.y);
                }
            });
            
            ctx.stroke();
            
            // Draw waypoints
            ctx.fillStyle = '#ffff00';
            testPath.forEach((point, index) => {
                ctx.beginPath();
                ctx.arc(point.x, point.y, 5, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#000';
                ctx.font = '12px Arial';
                ctx.fillText(index.toString(), point.x - 3, point.y + 4);
                ctx.fillStyle = '#ffff00';
            });
        }

        // Global functions for button handlers
        window.placeTower = function(type) {
            try {
                // Place tower at semi-random position, avoiding path
                const x = 150 + Math.random() * 500;
                const y = 100 + Math.random() * 400;
                
                const tower = new Tower(x, y, type, 1);
                towers.push(tower);
                
                log(`Placed ${type} tower at (${Math.round(x)}, ${Math.round(y)})`, 'success');
                
            } catch (error) {
                log(`Failed to place ${type} tower: ${error.message}`, 'error');
                console.error('Tower placement error:', error);
            }
        };

        window.spawnEnemy = function() {
            try {
                const enemy = new Enemy(testPath[0].x, testPath[0].y, 'basic');
                enemy.path = testPath;
                enemies.push(enemy);
                
                log(`Spawned enemy at start of path`, 'success');
                
            } catch (error) {
                log(`Failed to spawn enemy: ${error.message}`, 'error');
                console.error('Enemy spawn error:', error);
            }
        };

        window.clearAll = function() {
            towers = [];
            enemies = [];
            log('Cleared all entities', 'info');
        };

        // Start the debug test
        initDebugTest();

    </script>
</body>
</html>
