<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TDG Phase 2 - TowerAnimator Factory Test</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background: #f0f0f0; }
        canvas { border: 1px solid #333; margin: 10px; background: white; }
        .test-section { margin: 20px 0; padding: 15px; background: white; border-radius: 5px; }
        .tower-row { display: flex; align-items: center; margin: 10px 0; }
        .controls { margin: 10px 0; }
        button { margin: 5px; padding: 8px 16px; cursor: pointer; }
        .status { padding: 10px; margin: 10px 0; border-radius: 3px; }
        .success { background: #d4edda; border: 1px solid #c3e6cb; color: #155724; }
        .error { background: #f8d7da; border: 1px solid #f5c6cb; color: #721c24; }
    </style>
</head>
<body>
    <h1>TDG Phase 2 Validation: Tower Animator Factory</h1>
    
    <div class="test-section">
        <h2>Animation Test Results</h2>
        <div id="test-results"></div>
    </div>

    <div class="test-section">
        <h2>Basic Tower (Church) - T1/T2/T3</h2>
        <div class="tower-row">
            <canvas id="basic-t1" width="150" height="200"></canvas>
            <canvas id="basic-t2" width="150" height="200"></canvas>
            <canvas id="basic-t3" width="150" height="200"></canvas>
        </div>
        <div class="controls">
            <button onclick="triggerFire('basic')">Trigger Fire Animation</button>
            <button onclick="toggleIdle('basic')">Toggle Idle</button>
        </div>
    </div>

    <div class="test-section">
        <h2>Sniper Tower - T1/T2/T3</h2>
        <div class="tower-row">
            <canvas id="sniper-t1" width="150" height="200"></canvas>
            <canvas id="sniper-t2" width="150" height="200"></canvas>
            <canvas id="sniper-t3" width="150" height="200"></canvas>
        </div>
        <div class="controls">
            <button onclick="triggerFire('sniper')">Trigger Fire Animation</button>
            <button onclick="toggleIdle('sniper')">Toggle Idle</button>
        </div>
    </div>

    <div class="test-section">
        <h2>Rapid Tower (Uses Sniper Animator with Speed Modifier) - T1/T2/T3</h2>
        <div class="tower-row">
            <canvas id="rapid-t1" width="150" height="200"></canvas>
            <canvas id="rapid-t2" width="150" height="200"></canvas>
            <canvas id="rapid-t3" width="150" height="200"></canvas>
        </div>
        <div class="controls">
            <button onclick="triggerFire('rapid')">Trigger Fire Animation</button>
            <button onclick="toggleIdle('rapid')">Toggle Idle</button>
        </div>
    </div>

    <!-- Load our modules -->
    <script type="module">
        import { TowerAnimator, TowerAnimState } from './src/entities/towerAnimator.js';

        // Test state
        const animators = {};
        const contexts = {};
        let lastTime = 0;

        // Initialize test
        async function initTest() {
            try {
                const resultDiv = document.getElementById('test-results');
                
                // Test 1: Create animators for each type and tier
                const types = ['basic', 'sniper', 'rapid'];
                const tiers = [1, 2, 3];
                
                for (const type of types) {
                    animators[type] = {};
                    contexts[type] = {};
                    
                    for (const tier of tiers) {
                        // Create animator
                        const animator = new TowerAnimator(type, tier);
                        animators[type][tier] = animator;
                        
                        // Get canvas context
                        const canvas = document.getElementById(`${type}-t${tier}`);
                        const ctx = canvas.getContext('2d');
                        contexts[type][tier] = { canvas, ctx };
                        
                        // Initial render
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        animator.render(ctx, canvas.width / 2, canvas.height - 20, 1);
                        
                        // Label the canvas
                        ctx.fillStyle = '#333';
                        ctx.font = '12px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(`${type.toUpperCase()} T${tier}`, canvas.width / 2, 15);
                    }
                }

                // Test 2: Verify interface compliance
                const testAnimator = new TowerAnimator('basic', 1);
                const requiredMethods = ['update', 'render', 'triggerFire', 'setTier', 'getState'];
                const missingMethods = requiredMethods.filter(method => typeof testAnimator[method] !== 'function');
                
                if (missingMethods.length === 0) {
                    addResult('‚úÖ Interface Compliance: All required methods present', 'success');
                } else {
                    addResult(`‚ùå Interface Compliance: Missing methods: ${missingMethods.join(', ')}`, 'error');
                }

                // Test 3: Factory routing
                const basicAnimator = new TowerAnimator('basic', 1);
                const sniperAnimator = new TowerAnimator('sniper', 1);
                const rapidAnimator = new TowerAnimator('rapid', 1);
                
                if (basicAnimator._impl.constructor.name === 'ChurchTowerAnimator') {
                    addResult('‚úÖ Factory Routing: Basic tower uses ChurchTowerAnimator', 'success');
                } else {
                    addResult(`‚ùå Factory Routing: Basic tower should use ChurchTowerAnimator, got ${basicAnimator._impl.constructor.name}`, 'error');
                }
                
                if (sniperAnimator._impl.constructor.name === 'SniperTowerAnimator') {
                    addResult('‚úÖ Factory Routing: Sniper tower uses SniperTowerAnimator', 'success');
                } else {
                    addResult(`‚ùå Factory Routing: Sniper tower should use SniperTowerAnimator, got ${sniperAnimator._impl.constructor.name}`, 'error');
                }
                
                if (rapidAnimator._impl.constructor.name === 'SniperTowerAnimator') {
                    addResult('‚úÖ Factory Routing: Rapid tower reuses SniperTowerAnimator', 'success');
                } else {
                    addResult(`‚ùå Factory Routing: Rapid tower should reuse SniperTowerAnimator, got ${rapidAnimator._impl.constructor.name}`, 'error');
                }

                // Test 4: Animation states
                if (testAnimator.getState() === 'idle') {
                    addResult('‚úÖ Default State: Animators start in idle state', 'success');
                } else {
                    addResult(`‚ùå Default State: Expected 'idle', got '${testAnimator.getState()}'`, 'error');
                }

                addResult('‚úÖ Phase 2 TowerAnimator Factory System: Initialization Complete', 'success');

                // Start animation loop
                requestAnimationFrame(animate);

            } catch (error) {
                addResult(`‚ùå Critical Error: ${error.message}`, 'error');
                console.error('Test initialization failed:', error);
            }
        }

        function addResult(message, type) {
            const resultDiv = document.getElementById('test-results');
            const div = document.createElement('div');
            div.className = `status ${type}`;
            div.textContent = message;
            resultDiv.appendChild(div);
        }

        function animate(currentTime) {
            const deltaTime = (currentTime - lastTime) / 1000;
            lastTime = currentTime;

            // Update and render all animators
            for (const type in animators) {
                for (const tier in animators[type]) {
                    const animator = animators[type][tier];
                    const { canvas, ctx } = contexts[type][tier];
                    
                    // Update
                    animator.update(deltaTime);
                    
                    // Clear and render
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    animator.render(ctx, canvas.width / 2, canvas.height - 20, 1);
                    
                    // Re-add label
                    ctx.fillStyle = '#333';
                    ctx.font = '12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(`${type.toUpperCase()} T${tier}`, canvas.width / 2, 15);
                    
                    // Show state
                    ctx.fillText(`State: ${animator.getState()}`, canvas.width / 2, 30);
                }
            }

            requestAnimationFrame(animate);
        }

        // Export functions for button handlers
        window.triggerFire = function(type) {
            if (animators[type]) {
                Object.values(animators[type]).forEach(animator => animator.triggerFire());
                addResult(`üéØ Triggered fire animation for all ${type} towers`, 'success');
            }
        };

        window.toggleIdle = function(type) {
            if (animators[type]) {
                Object.values(animators[type]).forEach(animator => animator.setState('idle'));
                addResult(`‚è∏Ô∏è  Reset ${type} towers to idle state`, 'success');
            }
        };

        // Start the test
        initTest();

    </script>
</body>
</html>
